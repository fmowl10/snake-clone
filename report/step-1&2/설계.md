# snake rule-1

## 목차
1. [설계](#설계)

    1.[클래스](#클래스)

    2.[열거체](#열거체)

    3.[나머지](#나머지)

2. [내부코드](#내부코드)

3. [실행결과](#실행결과)

    1.[중간단계](#중간단계)

    2.[최종단계](#최종단계)


### 설계
board 클래스에서 입출력과 데이터 처리를 하는 형식 형식

loop 사용자의 입력을 받고 반대로 움직이는 지 확인하고 update 호출

update snake를 움직이고 죽는 위치인가 몸에 충돌 했는 지 등의 충돌 체크

print 현재 상태 화면에 출력

#### 클래스

Board 클래스
---
```cpp
    // 전체맵
    vector<vector<short>> board;
    // 맵사이즈
    const int size;
    // ncurses의 window 객체
    WINDOW *win;
    // snake 객체
    Snake user;

    // ncurses에서 색 관련 처리를 하기 윈한 변수
    static bool isInitColor;

    // 값이 합당한지 처리하고 print를 호출 하는 메소드
    bool update();
    // board를 참고하여 win을 이용하여 화면에 출력
    void print();

    // 죽은 이유
    DeadCase deadCase;

public:
    Board(int size = 21);
    
    //사용자의 입력을 받고 update에 넘겨주는 메소드
    int loop();
    // 죽은 이유를 반환하는 메소드
    DeadCase why();
    // ncurses 시스템에서 색을 초기화 하는 메소드 (프로그램 당 한번 만 실행됨)
    static void initColor();
```

BoardMiniumSizeExecption
execption 클래스
Board 클래스 생성시 thow되는 클래스
```cpp
    const char *what() 
    {
        return "too small board size, minium is 21";
    }
```

Snake 클래스
```cpp
private:
    int bodyLength;
    vector<Point> body;
    //현재 움직이는 방향
    Direct direct;
    bool isColide = false;

public:
    Snake(int size)
    {
        bodyLength = 3;
        for (int i = 0; i < 3; i++)
        {
            body.push_back(Point((size / 2) + i, (size / 2)));
        }
        direct = Direct::W;
    }

    // 헤드와 바디들을 방향에 맞게 위치값 변경
    void move();

    // 방향 변경
    void changeDirect(Direct d) { direct = d; }
    // 죽었는지 확인
    bool isDead() { return isColide; }
```

point 클래스 
x, y 좌표 값을 가지는 클래스
```cpp
    int x;
    int y;

    Point(int dx, int dy) : x(dx), y(dy) {}

    Point &operator=(const Point &p)
    {
        x = p.x;
        y = p.y;
        return *this;
    }
    bool operator==(const Point &p)
    {
        if (x == p.x && y == p.y)
            return true;
        else
            return false;
    }
```

#### 열거체
```cpp
enum DeadCase
{
    ColideWall, // 벽에 부딛힌 경우
    ColideBody, // 몸에 부딛힌 경우
    OppositeWay, // 반대 방향으로 간 경우
};
```cpp
// error 메시지
const string DeadMessage[3] = {
    "you hit the wall",
    "you hit the body",
    "you move to your body",
};
```

진행 방향을 저장하는 열거체 서로 반대 방향인 값을 XOR 연산하면 Opposite이 나옴
```cpp
enum Direct
{
    NONE = 0b0000,
    N = 0b0101,
    S = 0b1010,
    W = 0b1100,
    E = 0b0011,
    Opposite = 0b1111,
};
```

#### 나머지

컬러 코드 전처리 변수
ncurses에서 short로 처리하는 부분이 많아 short로 처리
```cpp
#define WALL short(1)
#define IMMUNE_WALL short(2)
#define SNAKE_HEAD short(3)
#define SNAKE_BODY short(4)
```

DeadCase에 대칭 되는 문자열들
```cpp
// enum to data
const string DeadMessage[3] = {
    "you hit the wall",
    "you hit the body",
    "you move to your body",
};
```

### 내부코드
Board 생성자
```cpp

Board::Board(int size) : size(size), user(Snake(size))
{
    // 크기가 너무 작으면 반환
    if (size < 20)
        throw BoardMiniumSizeException();
    win = newwin(size, size * 2, 2, 2);
    // ncurses가 생성 못하면 반환
    if (win == nullptr)
        throw exception();
    // 방향키 설정
    keypad(win, true);

    // 맵 설정 (가장자리에 벽 처리)
    for (int i = 0; i < size; i++)
    {
        board.push_back({});
        for (int j = 0; j < size; j++)
        {
            int value = 0;
            if (i == 0 || i + 1 == size)
            {
                value = 1;
            }
            if (j == 0 || j + 1 == size)
            {
                value += 1;
            }
            board[i].push_back(value);
            if (i == 0 || i + 1 == size)
            {
                value = 1;
            }
            value = 0;
        }
    }
}
```
board.loop
```cpp
    // ncurses 시스템 색 초기화
    Board::initColor();
    // tic 조절
    timeout(500);
    noecho();

    //현재 모습 출력
    print();
    while (true)
    {
        // 입력처리
        int input = getch();
        Direct d = Direct::NONE;
        switch (input)
        {
        case KEY_UP:
        case 'w':
            d = Direct::N;
            break;
        case KEY_DOWN:
        case 's':
            d = Direct::S;
            break;
        case KEY_LEFT:
        case 'a':
            d = Direct::W;
            break;
        case KEY_RIGHT:
        case 'd':
            d = Direct::E;
            break;
        case 'q':
            return EXIT_SUCCESS;
        }
        // 반대 방향으로 움직였는 지 확인
        if ((d ^ user.direct) == Direct::Opposite)
        {
            deadCase = DeadCase::OppositeWay;
            return EXIT_FAILURE;
        }
        // 방향 전환 적용
        if (d != Direct::NONE)
        {
            user.changeDirect(d);
        }
        // 값 업데이트 및 유효한가 확인후 현재 상황 출력
        if (update())
        {
            print();
        }
        else
        {
            // 죽으면 반환
            return EXIT_FAILURE;
        }
    }
```

board update
```cpp
bool Board::update()
{
    // 유저 이동
    user.move();
    // 몸 충돌 체크
    if (user.isDead())
    {
        // 죽은 이유 설정
        deadCase = DeadCase::ColideBody;
        return false;
    }
    //벽 충돌 체크
    Point head = user.body[0];
    if (1 <= board[head.y][head.x] && board[head.y][head.x] <= 2)
    {
        deadCase = DeadCase::ColideWall;
        return false;
    }
    // snake가 살아 있으면 true 반환
    return true;
}
```

board print
```cpp
void Board::print()
{
    // 벽 출력 
    for (int i = 0; i < size; i++)
    {
        for (int j = 0; j < size; j++)
        {
            wattron(win, COLOR_PAIR(board[i][j]));
            wmove(win, i, j * 2);
            waddch(win, '.');
            wmove(win, i, j * 2 + 1);
            waddch(win, '.');
            wattroff(win, COLOR_PAIR(board[i][j]));
        }
    }

    // snake 출력
    for (int i = 0; i < user.bodyLength; i++)
    {
        short color = 0;
        // head
        if (i == 0)
        {
            color = SNAKE_HEAD;
        }
        else
        {
            color = SNAKE_BODY;
        }

        wattron(win, COLOR_PAIR(color));

        wmove(win, user.body[i].y, user.body[i].x * 2);
        waddch(win, ' ');

        wmove(win, user.body[i].y, user.body[i].x * 2 + 1);
        waddch(win, ' ');

        wattroff(win, COLOR_PAIR(color));
    }
    wrefresh(win);
}


```




### 실행결과
___
#### 중간단계

ncurses 숙달용 무작위 위치에 커서 옮기기 

[![random_cur](https://img.youtube.com/vi/QXMm_t3SSwk/0.jpg)](https://youtu.be/QXMm_t3SSwk)

https://youtu.be/QXMm_t3SSwk

키보드 입력 + 1단계

[![keyboard](https://img.youtube.com/vi/cO4-FoBzrTY/0.jpg)](https://youtu.be/cO4-FoBzrTY)

https://youtu.be/cO4-FoBzrTY

키보드 입력 + 색 변경

[![drawing](https://img.youtube.com/vi/fMjE5YYulFg/0.jpg)](https://youtu.be/fMjE5YYulFg)

https://youtu.be/fMjE5YYulFg

스네이크 중간 테스트

[![snake-rule-1-test](https://img.youtube.com/vi/ziGmxyRU3oU/0.jpg)](https://youtu.be/ziGmxyRU3oU)

https://youtu.be/ziGmxyRU3oU

마우스 입력

[![mouse_input](https://img.youtube.com/vi/h4UN7NIy4xk/0.jpg)](https://youtu.be/h4UN7NIy4xk)

https://youtu.be/h4UN7NIy4xk

#### 최종단계

반대 방향

[![rule1-oppsite](https://img.youtube.com/vi/qPiEnMJlcNY/0.jpg)](https://youtu.be/qPiEnMJlcNY)

https://youtu.be/qPiEnMJlcNY

벽에 충돌

[![rule1-oppsite](https://img.youtube.com/vi/_TjKu7WsLsc/0.jpg)](https://youtu.be/_TjKu7WsLsc)

https://youtu.be/_TjKu7WsLsc


